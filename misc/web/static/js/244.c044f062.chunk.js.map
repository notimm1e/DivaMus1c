{"version":3,"sources":["../node_modules/highlight.js/lib/languages/elixir.js","../node_modules/highlight.js/lib/languages/elixir.js.js"],"names":["source","re","concat","args","joined","map","x","join","module","exports","hljs","ELIXIR_IDENT_RE","KWS","$pattern","keyword","literal","SUBST","className","begin","end","keywords","BACKSLASH_ESCAPE","match","scope","relevance","SIGIL_DELIMITER_MODES","escapeSigilEnd","LOWERCASE_SIGIL","contains","inherit","UPCASE_SIGIL","REGEX_SIGIL","variants","STRING","FUNCTION","beginKeywords","TITLE_MODE","endsParent","CLASS","ELIXIR_DEFAULT_CONTAINS","HASH_COMMENT_MODE","name","aliases","emitWarning","warned","console","log","require"],"mappings":"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","file":"static/js/244.c044f062.chunk.js","sourcesContent":["/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n\n  return re.source;\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join(\"\");\n  return joined;\n}\n\n/*\nLanguage: Elixir\nAuthor: Josh Adams <josh@isotope11.com>\nDescription: language definition for Elixir source code files (.ex and .exs).  Based on ruby language support.\nCategory: functional\nWebsite: https://elixir-lang.org\n*/\n\n/** @type LanguageFn */\nfunction elixir(hljs) {\n  const ELIXIR_IDENT_RE = '[a-zA-Z_][a-zA-Z0-9_.]*(!|\\\\?)?';\n  const ELIXIR_METHOD_RE = '[a-zA-Z_]\\\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\\\*\\\\*|[-/+%^&*~`|]|\\\\[\\\\]=?';\n  const KEYWORDS = [\n    \"after\",\n    \"alias\",\n    \"and\",\n    \"case\",\n    \"catch\",\n    \"cond\",\n    \"defstruct\",\n    \"do\",\n    \"else\",\n    \"end\",\n    \"fn\",\n    \"for\",\n    \"if\",\n    \"import\",\n    \"in\",\n    \"not\",\n    \"or\",\n    \"quote\",\n    \"raise\",\n    \"receive\",\n    \"require\",\n    \"reraise\",\n    \"rescue\",\n    \"try\",\n    \"unless\",\n    \"unquote\",\n    \"unquote_splicing\",\n    \"use\",\n    \"when\",\n    \"with|0\"\n  ];\n  const LITERALS = [\n    \"false\",\n    \"nil\",\n    \"true\"\n  ];\n  const KWS = {\n    $pattern: ELIXIR_IDENT_RE,\n    keyword: KEYWORDS,\n    literal: LITERALS\n  };\n  const SUBST = {\n    className: 'subst',\n    begin: /#\\{/,\n    end: /\\}/,\n    keywords: KWS\n  };\n  const NUMBER = {\n    className: 'number',\n    begin: '(\\\\b0o[0-7_]+)|(\\\\b0b[01_]+)|(\\\\b0x[0-9a-fA-F_]+)|(-?\\\\b[0-9][0-9_]*(\\\\.[0-9_]+([eE][-+]?[0-9]+)?)?)',\n    relevance: 0\n  };\n  // TODO: could be tightened\n  // https://elixir-lang.readthedocs.io/en/latest/intro/18.html\n  // but you also need to include closing delemeters in the escape list per\n  // individual sigil mode from what I can tell,\n  // ie: \\} might or might not be an escape depending on the sigil used\n  const ESCAPES_RE = /\\\\[\\s\\S]/;\n  // const ESCAPES_RE = /\\\\[\"'\\\\abdefnrstv0]/;\n  const BACKSLASH_ESCAPE = {\n    match: ESCAPES_RE,\n    scope: \"char.escape\",\n    relevance: 0\n  };\n  const SIGIL_DELIMITERS = '[/|([{<\"\\']';\n  const SIGIL_DELIMITER_MODES = [\n    {\n      begin: /\"/,\n      end: /\"/\n    },\n    {\n      begin: /'/,\n      end: /'/\n    },\n    {\n      begin: /\\//,\n      end: /\\//\n    },\n    {\n      begin: /\\|/,\n      end: /\\|/\n    },\n    {\n      begin: /\\(/,\n      end: /\\)/\n    },\n    {\n      begin: /\\[/,\n      end: /\\]/\n    },\n    {\n      begin: /\\{/,\n      end: /\\}/\n    },\n    {\n      begin: /</,\n      end: />/\n    }\n  ];\n  const escapeSigilEnd = (end) => {\n    return {\n      scope: \"char.escape\",\n      begin: concat(/\\\\/, end),\n      relevance: 0\n    };\n  };\n  const LOWERCASE_SIGIL = {\n    className: 'string',\n    begin: '~[a-z]' + '(?=' + SIGIL_DELIMITERS + ')',\n    contains: SIGIL_DELIMITER_MODES.map(x => hljs.inherit(x,\n      {\n        contains: [\n          escapeSigilEnd(x.end),\n          BACKSLASH_ESCAPE,\n          SUBST\n        ]\n      }\n    ))\n  };\n\n  const UPCASE_SIGIL = {\n    className: 'string',\n    begin: '~[A-Z]' + '(?=' + SIGIL_DELIMITERS + ')',\n    contains: SIGIL_DELIMITER_MODES.map(x => hljs.inherit(x,\n      {\n        contains: [ escapeSigilEnd(x.end) ]\n      }\n    ))\n  };\n\n  const REGEX_SIGIL = {\n    className: 'regex',\n    variants: [\n      {\n        begin: '~r' + '(?=' + SIGIL_DELIMITERS + ')',\n        contains: SIGIL_DELIMITER_MODES.map(x => hljs.inherit(x,\n          {\n            end: concat(x.end, /[uismxfU]{0,7}/),\n            contains: [\n              escapeSigilEnd(x.end),\n              BACKSLASH_ESCAPE,\n              SUBST\n            ]\n          }\n        ))\n      },\n      {\n        begin: '~R' + '(?=' + SIGIL_DELIMITERS + ')',\n        contains: SIGIL_DELIMITER_MODES.map(x => hljs.inherit(x,\n          {\n            end: concat(x.end, /[uismxfU]{0,7}/),\n            contains: [ escapeSigilEnd(x.end) ]\n          })\n        )\n      }\n    ]\n  };\n\n  const STRING = {\n    className: 'string',\n    contains: [\n      hljs.BACKSLASH_ESCAPE,\n      SUBST\n    ],\n    variants: [\n      {\n        begin: /\"\"\"/,\n        end: /\"\"\"/\n      },\n      {\n        begin: /'''/,\n        end: /'''/\n      },\n      {\n        begin: /~S\"\"\"/,\n        end: /\"\"\"/,\n        contains: [] // override default\n      },\n      {\n        begin: /~S\"/,\n        end: /\"/,\n        contains: [] // override default\n      },\n      {\n        begin: /~S'''/,\n        end: /'''/,\n        contains: [] // override default\n      },\n      {\n        begin: /~S'/,\n        end: /'/,\n        contains: [] // override default\n      },\n      {\n        begin: /'/,\n        end: /'/\n      },\n      {\n        begin: /\"/,\n        end: /\"/\n      }\n    ]\n  };\n  const FUNCTION = {\n    className: 'function',\n    beginKeywords: 'def defp defmacro defmacrop',\n    end: /\\B\\b/, // the mode is ended by the title\n    contains: [\n      hljs.inherit(hljs.TITLE_MODE, {\n        begin: ELIXIR_IDENT_RE,\n        endsParent: true\n      })\n    ]\n  };\n  const CLASS = hljs.inherit(FUNCTION, {\n    className: 'class',\n    beginKeywords: 'defimpl defmodule defprotocol defrecord',\n    end: /\\bdo\\b|$|;/\n  });\n  const ELIXIR_DEFAULT_CONTAINS = [\n    STRING,\n    REGEX_SIGIL,\n    UPCASE_SIGIL,\n    LOWERCASE_SIGIL,\n    hljs.HASH_COMMENT_MODE,\n    CLASS,\n    FUNCTION,\n    {\n      begin: '::'\n    },\n    {\n      className: 'symbol',\n      begin: ':(?![\\\\s:])',\n      contains: [\n        STRING,\n        {\n          begin: ELIXIR_METHOD_RE\n        }\n      ],\n      relevance: 0\n    },\n    {\n      className: 'symbol',\n      begin: ELIXIR_IDENT_RE + ':(?!:)',\n      relevance: 0\n    },\n    NUMBER,\n    {\n      className: 'variable',\n      begin: '(\\\\$\\\\W)|((\\\\$|@@?)(\\\\w+))'\n    },\n    {\n      begin: '->'\n    }\n  ];\n  SUBST.contains = ELIXIR_DEFAULT_CONTAINS;\n\n  return {\n    name: 'Elixir',\n    aliases: ['ex', 'exs'],\n    keywords: KWS,\n    contains: ELIXIR_DEFAULT_CONTAINS\n  };\n}\n\nmodule.exports = elixir;\n","function emitWarning() {\n    if (!emitWarning.warned) {\n      emitWarning.warned = true;\n      console.log(\n        'Deprecation (warning): Using file extension in specifier is deprecated, use \"highlight.js/lib/languages/elixir\" instead of \"highlight.js/lib/languages/elixir.js\"'\n      );\n    }\n  }\n  emitWarning();\n    module.exports = require('./elixir.js');"],"sourceRoot":""}