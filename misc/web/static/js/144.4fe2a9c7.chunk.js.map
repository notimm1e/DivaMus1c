{"version":3,"sources":["../node_modules/highlight.js/lib/languages/r.js"],"names":["source","re","lookahead","args","map","x","join","concat","stripOptionsFromArgs","opts","length","constructor","Object","splice","either","joined","capture","module","exports","hljs","IDENT_RE","NUMBER_TYPES_RE","OPERATORS_RE","PUNCTUATION_RE","name","keywords","$pattern","keyword","literal","built_in","contains","COMMENT","scope","match","starts","end","endsParent","begin","variants","HASH_COMMENT_MODE","BACKSLASH_ESCAPE","END_SAME_AS_BEGIN","relevance"],"mappings":"yFASA,SAASA,EAAOC,GACd,OAAKA,EACa,kBAAPA,EAAwBA,EAE5BA,EAAGD,OAHM,KAUlB,SAASE,EAAUD,GACjB,OAOF,WAAyB,2BAANE,EAAM,yBAANA,EAAM,gBAEvB,OADeA,EAAKC,KAAI,SAACC,GAAD,OAAOL,EAAOK,MAAIC,KAAK,IARxCC,CAAO,MAAON,EAAI,KAY3B,SAASO,EAAqBL,GAC5B,IAAMM,EAAON,EAAKA,EAAKO,OAAS,GAEhC,MAAoB,kBAATD,GAAqBA,EAAKE,cAAgBC,QACnDT,EAAKU,OAAOV,EAAKO,OAAS,EAAG,GACtBD,GAEA,GAWX,SAASK,IAAgB,2BAANX,EAAM,yBAANA,EAAM,gBACvB,IAAMM,EAAOD,EAAqBL,GAC5BY,EAAS,KACZN,EAAKO,QAAU,GAAK,MACrBb,EAAKC,KAAI,SAACC,GAAD,OAAOL,EAAOK,MAAIC,KAAK,KAAO,IACzC,OAAOS,EA4OTE,EAAOC,QA/NP,SAAWC,GAOT,IAAMC,EAAW,uDACXC,EAAkBP,EAEtB,gDAEA,0CAEA,iDAEIQ,EAAe,mEACfC,EAAiBT,EACrB,OACA,OACA,OACA,QACA,KACA,KAGF,MAAO,CACLU,KAAM,IAENC,SAAU,CACRC,SAAUN,EACVO,QACE,kDACFC,QACE,wFAEFC,SAEE,khCAuBJC,SAAU,CAERX,EAAKY,QACH,KACA,IACA,CACED,SAAU,CACR,CAMEE,MAAO,SACPC,MAAO,YACPC,OAAQ,CACNC,IAAKjC,EAAUY,EAEb,yBAEA,cAEFsB,YAAY,IAGhB,CAGEJ,MAAO,SACPK,MAAO,SACPF,IAAK,IACLL,SAAU,CACR,CACEE,MAAO,WACPM,SAAU,CACR,CAAEL,MAAOb,GACT,CAAEa,MAAO,sBAEXG,YAAY,KAIlB,CACEJ,MAAO,SACPC,MAAO,cAET,CACED,MAAO,UACPC,MAAO,kBAMfd,EAAKoB,kBAEL,CACEP,MAAO,SACPF,SAAU,CAACX,EAAKqB,kBAChBF,SAAU,CACRnB,EAAKsB,kBAAkB,CAAEJ,MAAO,cAAeF,IAAK,YACpDhB,EAAKsB,kBAAkB,CAAEJ,MAAO,cAAeF,IAAK,YACpDhB,EAAKsB,kBAAkB,CAAEJ,MAAO,cAAeF,IAAK,YACpDhB,EAAKsB,kBAAkB,CAAEJ,MAAO,cAAeF,IAAK,YACpDhB,EAAKsB,kBAAkB,CAAEJ,MAAO,cAAeF,IAAK,YACpDhB,EAAKsB,kBAAkB,CAAEJ,MAAO,cAAeF,IAAK,YACpD,CAACE,MAAO,IAAKF,IAAK,IAAKO,UAAW,GAClC,CAACL,MAAO,IAAKF,IAAK,IAAKO,UAAW,KAatC,CACEA,UAAW,EACXJ,SAAU,CACR,CACEN,MAAO,CACL,EAAG,WACH,EAAG,UAELC,MAAO,CACLX,EACAD,IAGJ,CACEW,MAAO,CACL,EAAG,WACH,EAAG,UAELC,MAAO,CACL,UACAZ,IAGJ,CACEW,MAAO,CACL,EAAG,cACH,EAAG,UAELC,MAAO,CACLV,EACAF,IAGJ,CACEW,MAAO,CAAE,EAAG,UACZC,MAAO,CACL,mBACAZ,MAOR,CAEEW,MAAO,CAAE,EAAG,YACZC,MAAO,CACLb,EACA,MACA,KACA,QAIJ,CACEY,MAAO,WACPU,UAAW,EACXJ,SAAU,CACR,CAAEL,MAAOX,GACT,CAAEW,MAAO,aAIb,CACED,MAAO,cACPU,UAAW,EACXT,MAAOV,GAGT,CAEEc,MAAO,IACPF,IAAK,IACLL,SAAU,CACR,CAAEO,MAAO","file":"static/js/144.4fe2a9c7.chunk.js","sourcesContent":["/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join(\"\");\n  return joined;\n}\n\nfunction stripOptionsFromArgs(args) {\n  const opts = args[args.length - 1];\n\n  if (typeof opts === 'object' && opts.constructor === Object) {\n    args.splice(args.length - 1, 1);\n    return opts;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */\nfunction either(...args) {\n  const opts = stripOptionsFromArgs(args);\n  const joined = '(' +\n    (opts.capture ? \"\" : \"?:\") +\n    args.map((x) => source(x)).join(\"|\") + \")\";\n  return joined;\n}\n\n/*\nLanguage: R\nDescription: R is a free software environment for statistical computing and graphics.\nAuthor: Joe Cheng <joe@rstudio.org>\nContributors: Konrad Rudolph <konrad.rudolph@gmail.com>\nWebsite: https://www.r-project.org\nCategory: common,scientific\n*/\n\n/** @type LanguageFn */\nfunction r(hljs) {\n  // Identifiers in R cannot start with `_`, but they can start with `.` if it\n  // is not immediately followed by a digit.\n  // R also supports quoted identifiers, which are near-arbitrary sequences\n  // delimited by backticks (`…`), which may contain escape sequences. These are\n  // handled in a separate mode. See `test/markup/r/names.txt` for examples.\n  // FIXME: Support Unicode identifiers.\n  const IDENT_RE = /(?:(?:[a-zA-Z]|\\.[._a-zA-Z])[._a-zA-Z0-9]*)|\\.(?!\\d)/;\n  const NUMBER_TYPES_RE = either(\n    // Special case: only hexadecimal binary powers can contain fractions\n    /0[xX][0-9a-fA-F]+\\.[0-9a-fA-F]*[pP][+-]?\\d+i?/,\n    // Hexadecimal numbers without fraction and optional binary power\n    /0[xX][0-9a-fA-F]+(?:[pP][+-]?\\d+)?[Li]?/,\n    // Decimal numbers\n    /(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?[Li]?/\n  );\n  const OPERATORS_RE = /[=!<>:]=|\\|\\||&&|:::?|<-|<<-|->>|->|\\|>|[-+*\\/?!$&|:<=>@^~]|\\*\\*/;\n  const PUNCTUATION_RE = either(\n    /[()]/,\n    /[{}]/,\n    /\\[\\[/,\n    /[[\\]]/,\n    /\\\\/,\n    /,/\n  );\n\n  return {\n    name: 'R',\n\n    keywords: {\n      $pattern: IDENT_RE,\n      keyword:\n        'function if in break next repeat else for while',\n      literal:\n        'NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 ' +\n        'NA_character_|10 NA_complex_|10',\n      built_in:\n        // Builtin constants\n        'LETTERS letters month.abb month.name pi T F ' +\n        // Primitive functions\n        // These are all the functions in `base` that are implemented as a\n        // `.Primitive`, minus those functions that are also keywords.\n        'abs acos acosh all any anyNA Arg as.call as.character ' +\n        'as.complex as.double as.environment as.integer as.logical ' +\n        'as.null.default as.numeric as.raw asin asinh atan atanh attr ' +\n        'attributes baseenv browser c call ceiling class Conj cos cosh ' +\n        'cospi cummax cummin cumprod cumsum digamma dim dimnames ' +\n        'emptyenv exp expression floor forceAndCall gamma gc.time ' +\n        'globalenv Im interactive invisible is.array is.atomic is.call ' +\n        'is.character is.complex is.double is.environment is.expression ' +\n        'is.finite is.function is.infinite is.integer is.language ' +\n        'is.list is.logical is.matrix is.na is.name is.nan is.null ' +\n        'is.numeric is.object is.pairlist is.raw is.recursive is.single ' +\n        'is.symbol lazyLoadDBfetch length lgamma list log max min ' +\n        'missing Mod names nargs nzchar oldClass on.exit pos.to.env ' +\n        'proc.time prod quote range Re rep retracemem return round ' +\n        'seq_along seq_len seq.int sign signif sin sinh sinpi sqrt ' +\n        'standardGeneric substitute sum switch tan tanh tanpi tracemem ' +\n        'trigamma trunc unclass untracemem UseMethod xtfrm',\n    },\n\n    contains: [\n      // Roxygen comments\n      hljs.COMMENT(\n        /#'/,\n        /$/,\n        {\n          contains: [\n            {\n              // Handle `@examples` separately to cause all subsequent code\n              // until the next `@`-tag on its own line to be kept as-is,\n              // preventing highlighting. This code is example R code, so nested\n              // doctags shouldn’t be treated as such. See\n              // `test/markup/r/roxygen.txt` for an example.\n              scope: 'doctag',\n              match: /@examples/,\n              starts: {\n                end: lookahead(either(\n                  // end if another doc comment\n                  /\\n^#'\\s*(?=@[a-zA-Z]+)/,\n                  // or a line with no comment\n                  /\\n^(?!#')/\n                )),\n                endsParent: true\n              }\n            },\n            {\n              // Handle `@param` to highlight the parameter name following\n              // after.\n              scope: 'doctag',\n              begin: '@param',\n              end: /$/,\n              contains: [\n                {\n                  scope: 'variable',\n                  variants: [\n                    { match: IDENT_RE },\n                    { match: /`(?:\\\\.|[^`\\\\])+`/ }\n                  ],\n                  endsParent: true\n                }\n              ]\n            },\n            {\n              scope: 'doctag',\n              match: /@[a-zA-Z]+/\n            },\n            {\n              scope: 'keyword',\n              match: /\\\\[a-zA-Z]+/\n            }\n          ]\n        }\n      ),\n\n      hljs.HASH_COMMENT_MODE,\n\n      {\n        scope: 'string',\n        contains: [hljs.BACKSLASH_ESCAPE],\n        variants: [\n          hljs.END_SAME_AS_BEGIN({ begin: /[rR]\"(-*)\\(/, end: /\\)(-*)\"/ }),\n          hljs.END_SAME_AS_BEGIN({ begin: /[rR]\"(-*)\\{/, end: /\\}(-*)\"/ }),\n          hljs.END_SAME_AS_BEGIN({ begin: /[rR]\"(-*)\\[/, end: /\\](-*)\"/ }),\n          hljs.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\\(/, end: /\\)(-*)'/ }),\n          hljs.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\\{/, end: /\\}(-*)'/ }),\n          hljs.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\\[/, end: /\\](-*)'/ }),\n          {begin: '\"', end: '\"', relevance: 0},\n          {begin: \"'\", end: \"'\", relevance: 0}\n        ],\n      },\n\n      // Matching numbers immediately following punctuation and operators is\n      // tricky since we need to look at the character ahead of a number to\n      // ensure the number is not part of an identifier, and we cannot use\n      // negative look-behind assertions. So instead we explicitly handle all\n      // possible combinations of (operator|punctuation), number.\n      // TODO: replace with negative look-behind when available\n      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\\.[0-9a-fA-F]*[pP][+-]?\\d+i?/ },\n      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\\d+)?[Li]?/ },\n      // { begin: /(?<![a-zA-Z0-9._])(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?[Li]?/ }\n      {\n        relevance: 0,\n        variants: [\n          {\n            scope: {\n              1: 'operator',\n              2: 'number'\n            },\n            match: [\n              OPERATORS_RE,\n              NUMBER_TYPES_RE\n            ]\n          },\n          {\n            scope: {\n              1: 'operator',\n              2: 'number'\n            },\n            match: [\n              /%[^%]*%/,\n              NUMBER_TYPES_RE\n            ]\n          },\n          {\n            scope: {\n              1: 'punctuation',\n              2: 'number'\n            },\n            match: [\n              PUNCTUATION_RE,\n              NUMBER_TYPES_RE\n            ]\n          },\n          {\n            scope: { 2: 'number' },\n            match: [\n              /[^a-zA-Z0-9._]|^/, // not part of an identifier, or start of document\n              NUMBER_TYPES_RE\n            ]\n          }\n        ]\n      },\n\n      // Operators/punctuation when they're not directly followed by numbers\n      {\n        // Relevance boost for the most common assignment form.\n        scope: { 3: 'operator' },\n        match: [\n          IDENT_RE,\n          /\\s+/,\n          /<-/,\n          /\\s+/\n        ]\n      },\n\n      {\n        scope: 'operator',\n        relevance: 0,\n        variants: [\n          { match: OPERATORS_RE },\n          { match: /%[^%]*%/ }\n        ]\n      },\n\n      {\n        scope: 'punctuation',\n        relevance: 0,\n        match: PUNCTUATION_RE\n      },\n\n      {\n        // Escaped identifier\n        begin: '`',\n        end: '`',\n        contains: [\n          { begin: /\\\\./ }\n        ]\n      }\n    ]\n  };\n}\n\nmodule.exports = r;\n"],"sourceRoot":""}